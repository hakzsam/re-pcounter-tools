.. _nvc0-graphics-counter-definitions:

=================================
NVC0 Graphics Counter Definitions
=================================

.. contents::

GPU signals
===========

- gpu_busy = 100% - gpu_idle
- gpu_idle = 100% - gpu_busy

.. _gpu_busy/gpu_idle:
gpu_busy/gpu_idle
-----------------

The % of time the GPU is idle/busy since the last call. Having the GPU idle at
all is a waste of valuable resources. You want to balance the GPU and CPU
workloads so that no one processor is starved for work.  Time management or
using multithreading in your application can help balance CPU based tasks
(world management, etc.) with the rendering pipeline.

SETUP signals
=============

.. _setup-primitive-count:
setup_primitive_count
---------------------

Returns the number of primitives processed in the geometry subsystem. This
experiments counts points, lines and triangles. To count only triangles, use
the setup_triangle_count counter. Balance these counts with the number of
pixels being drawn to see if you could simplify your geometry and use
bump/displacement maps, for example.

VS signals
==========

.. _vertex-shader-instruction-rate:
vertex_shader_instruction_rate
------------------------------

The % of all shader instructions seen on the first SM
unit that were executing vertex shaders.

.. _sm-instruction-count-vertex:
sm_instruction_count_vertex
---------------------------

The number of vertex shader instructions executed on the
given SM.

HS signals
==========

.. _hull-shader-instruction-rate:
hull_shader_instruction_rate
----------------------------

The % of all shader instructions seen on the first SM unit
that were executing hull shaders.

.. _sm-instruction-count-hull:
sm_instruction_count_hull
-------------------------

The number of hull shader instructions executed on the given SM.

DS signals
==========

.. _domain-shader-instruction-rate:
domain_shader_instruction_rate
------------------------------

The % of all shader instructions seen on the first SM unit that were
executing domain shaders.

.. _sm-instruction-count-domain:
sm_instruction_count_domain
---------------------------

The number of domain shader instructions executed on the given SM.

GS signals
==========

.. _geometry-shader-instruction-rate:
geometry_shader_instruction_rate
--------------------------------

The % of all shader instructions seen on the first SM unit that were
executing geometry shaders.

.. _sm-instruction-count-geometry:
sm_instruction_count_geometry
------------------------------

The number of geometry shader instructions executed on the given SM.

PS signals
==========

.. _pixel-shader-instruction-rate:
pixel_shader_instruction_rate
-----------------------------

The % of all shader instructions seen on the first SM unit that
were executing pixel shaders.

.. _sm-instruction-count-pixel:
sm_instruction_count_pixel
--------------------------

The number of pixel shader instructions executed on the given SM.

SHADER signals
==============

.. _shader-busy:
shader_busy
-----------

This measures the how active the unified shader unit is running any
type of shader. If you couple this information with the various
shader_instruction_rate values you can get an idea for the workload the
shader unit has and which shader types to tune if the shader uniti
becomes a bottleneck.

RASTER signals
==============

.. _shaded-pixel-count:
shaded_pixel_count
------------------

Counts the number of pixels generated by the rasterizer and
sent to the pixel shader units.

ROP signals
===========

.. _rop-busy:
rop_busy
--------

% of time that the ROP unit is actively doing work. This can be
high if alpha blending is turned on, of overdraw is high,
etc.

.. _crop-busy:
crop_busy
---------

XXX: NVPerfKit guide doesn't provide a description.

.. _zrop-busy:
zrop_busy
---------

XXX: NVPerfKit guide doesn't provide a description.

TEXTURE signals
===============

.. _texture-busy:
texture_busy
------------

This is a measu rement of how busy the texture unit is. This covers both
time spent sampling values from the frame buffer (through the texture cache)
and the time spent computing any filtering that is enabled (like bilinear or
anisotropic).  Reducing both the number of taps and the filtering level will
help to reduce any bottleneck in the texture unit.
